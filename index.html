<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC LocalStorage Sync</title>
    <!-- PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- Global Styles --- */
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --text-color: #212529;
            --border-color: #dee2e6;
            --card-bg: #ffffff;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        body {
            font-family: var(--font-family);
            margin: 0;
            background-color: #eef2f7; /* Lighter page background */
            color: var(--text-color);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 1rem 0;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        header h1 {
            margin: 0;
            font-size: 1.8rem;
            font-weight: 500;
        }

        .container {
            width: 90%;
            max-width: 900px;
            margin: 2rem auto;
            padding: 1rem;
            flex-grow: 1;
        }

        .card {
            background-color: var(--card-bg);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            margin-bottom: 2rem;
        }

        .card h2 {
            margin-top: 0;
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            font-weight: 500;
        }

        .card h3 {
            margin-top: 1.5rem;
            color: var(--dark-color);
            font-size: 1.2rem;
            font-weight: 500;
        }

        /* --- Status & Invite Section --- */
        #my-peer-id {
            font-weight: bold;
            padding: 0.2em 0.5em;
            border-radius: 4px;
            transition: background-color 0.3s, color 0.3s;
            display: inline-block; /* Makes padding and bg apply correctly */
        }
        .status-connecting {
            background-color: var(--warning-color);
            color: var(--dark-color);
        }
        .status-connected {
            background-color: var(--success-color);
            color: white;
        }
        .status-error {
            background-color: var(--danger-color);
            color: white;
        }
        .status-reconnecting {
            background-color: #fd7e14; /* Orange */
            color: white;
        }
        .status-disconnected {
            background-color: var(--secondary-color);
            color: white;
        }


        #invite-link-area label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .invite-input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #invite-link {
            flex-grow: 1;
            padding: 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--light-color);
            font-size: 0.9rem;
            color: var(--dark-color);
        }

        .copy-status-message {
            display: inline-block;
            margin-top: 0.5rem;
            font-size: 0.9em;
            color: var(--success-color);
            opacity: 0;
            transition: opacity 0.5s;
        }
        .copy-status-message.visible {
            opacity: 1;
        }

        /* --- Connection Management --- */
        #peer-list {
            list-style-type: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
        }

        #peer-list li {
            background-color: var(--light-color);
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            font-size: 0.95rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #peer-list li.no-peers {
            background-color: transparent;
            border: none;
            color: var(--secondary-color);
            font-style: italic;
        }
        .peer-status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-left: 10px;
            display: inline-block;
        }
        .peer-connected {
            background-color: var(--success-color);
        }
        .peer-connecting {
            background-color: var(--warning-color);
        }


        /* --- LocalStorage Management --- */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.3rem;
            font-weight: 500;
        }

        input[type="text"] {
            width: 100%;
            padding: 0.6rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box; /* Important for width 100% */
            font-size: 0.95rem;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(0,123,255,.25);
        }

        .button-group {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        button {
            padding: 0.6rem 1rem;
            font-size: 0.95rem;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            font-weight: 500;
        }
        button:hover {
            opacity: 0.9;
        }
        button:active {
            transform: translateY(1px);
        }

        .button-primary {
            background-color: var(--primary-color);
            color: white;
        }
        .button-secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        .button-success {
            background-color: var(--success-color);
            color: white;
        }
        .button-danger {
            background-color: var(--danger-color);
            color: white;
        }
        .button-warning {
            background-color: var(--warning-color);
            color: var(--dark-color);
        }

        pre#localstorage-display {
            background-color: var(--light-color);
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
            color: var(--dark-color);
        }

        footer {
            text-align: center;
            padding: 1.5rem 0;
            background-color: var(--dark-color);
            color: var(--light-color);
            font-size: 0.9rem;
            margin-top: auto; /* Pushes footer to bottom */
        }
        footer p {
            margin: 0;
        }
    </style>
</head>
<body>
    <header>
        <h1>WebRTC LocalStorage Sync</h1>
    </header>

    <main class="container">
        <section id="status-section" class="card">
            <h2>My Status & Invite</h2>
            <p>My Peer ID: <strong id="my-peer-id" class="status-connecting">Connecting...</strong></p>
            <div id="invite-link-area" style="display: none;">
                <label for="invite-link">Sharable Invite Link:</label>
                <div class="invite-input-group">
                    <input type="text" id="invite-link" readonly>
                    <button id="copy-invite-link" class="button-secondary">
                        Copy
                    </button>
                </div>
                <span id="copy-status" class="copy-status-message"></span>
            </div>
        </section>

        <section id="connection-management" class="card">
            <h2>Connected Peers (<span id="peer-count">0</span>)</h2>
            <ul id="peer-list">
                <li class="no-peers">No active connections.</li>
            </ul>
        </section>

        <section id="localstorage-management" class="card">
            <h2>LocalStorage Control</h2>
            <div class="form-grid">
                <div class="form-group">
                    <label for="ls-key">Key:</label>
                    <input type="text" id="ls-key" placeholder="Enter key">
                </div>
                <div class="form-group">
                    <label for="ls-value">Value:</label>
                    <input type="text" id="ls-value" placeholder="Enter value">
                </div>
            </div>
            <div class="button-group">
                <button id="ls-set" class="button-primary">Set Item</button>
                <button id="ls-remove" class="button-danger">Remove Item</button>
                <button id="ls-clear" class="button-danger">Clear All Local Items</button>
            </div>

            <h3>Current LocalStorage:</h3>
            <pre id="localstorage-display">{}</pre>
        </section>
    </main>

    <footer>
        <p>Powered by PeerJS & GitHub Pages</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const myPeerIdDisplay = document.getElementById('my-peer-id');
            const inviteLinkArea = document.getElementById('invite-link-area');
            const inviteLinkInput = document.getElementById('invite-link');
            const copyInviteLinkButton = document.getElementById('copy-invite-link');
            const copyStatusMessage = document.getElementById('copy-status');
            const peerList = document.getElementById('peer-list');
            const peerCountDisplay = document.getElementById('peer-count');

            const lsKeyInput = document.getElementById('ls-key');
            const lsValueInput = document.getElementById('ls-value');
            const lsSetButton = document.getElementById('ls-set');
            const lsRemoveButton = document.getElementById('ls-remove');
            const lsClearButton = document.getElementById('ls-clear');
            const localStorageDisplay = document.getElementById('localstorage-display');

            let peer;
            let myPeerId;
            const connections = {}; // Store active connections { peerId: DataConnection }
            let applyingRemoteChange = false; // Flag to prevent broadcast loops

            function setPeerIdStatus(status, message) {
                myPeerIdDisplay.className = ''; // Clear existing classes
                myPeerIdDisplay.classList.add(`status-${status}`);
                myPeerIdDisplay.textContent = message || status.charAt(0).toUpperCase() + status.slice(1);
                if (status === 'connected' && myPeerId) {
                    myPeerIdDisplay.textContent = myPeerId;
                }
            }

            // --- PeerJS Initialization ---
            function initializePeer() {
                setPeerIdStatus('connecting', 'Connecting...');
                peer = new Peer(undefined, {
                    // debug: 2
                });

                peer.on('open', (id) => {
                    myPeerId = id;
                    setPeerIdStatus('connected');
                    console.log('My Peer ID is: ' + id);
                    generateInviteLink();
                    inviteLinkArea.style.display = 'block';
                    checkUrlForAutoConnect();
                });

                peer.on('connection', (conn) => {
                    console.log('Incoming connection from:', conn.peer);
                    setupConnectionEventHandlers(conn);
                });

                peer.on('disconnected', () => {
                    console.log('Disconnected from PeerJS server. Attempting to reconnect...');
                    setPeerIdStatus('reconnecting', 'Reconnecting...');
                    // PeerJS often attempts to reconnect automatically.
                    // If it doesn't, or if you want more control:
                    // setTimeout(() => {
                    //     if (!peer.destroyed && !peer.disconnected) peer.reconnect();
                    // }, 3000);
                });

                peer.on('close', () => {
                    console.log('Peer destroyed (closed). Needs re-initialization.');
                    setPeerIdStatus('disconnected', 'Peer Closed. Refresh.');
                    // Handle this by possibly re-initializing 'peer' or disabling functionality
                });

                peer.on('error', (err) => {
                    console.error('PeerJS error:', err);
                    setPeerIdStatus('error', `Error: ${err.type || err.message}`);
                    if (err.type === 'peer-unavailable') {
                        alert(`Could not connect to peer: ${err.message.split('peer ').pop()}. They might be offline or the ID is incorrect.`);
                    } else if (err.type === 'network') {
                        // Often happens if PeerServer is down or internet connection lost
                        alert('Network error with PeerJS. Please check your connection or try again later.');
                    } else if (err.type === 'server-error') {
                        alert('PeerJS server error. Please try again later.');
                    }
                    // Consider re-initialization on some errors
                    // if (err.type === 'disconnected' || err.type === 'network' || err.type === 'server-error') {
                    //    setTimeout(initializePeer, 5000); // Try to re-init after a delay
                    // }
                });
            }

            // --- Connection Management ---
            function connectToPeer(targetPeerId) {
                if (!peer || peer.destroyed) {
                    alert("PeerJS is not initialized. Please wait or refresh.");
                    return;
                }
                if (targetPeerId === myPeerId) {
                    console.log("Cannot connect to self.");
                    return;
                }
                if (connections[targetPeerId] && connections[targetPeerId].open) {
                    console.log(`Already connected to ${targetPeerId}`);
                    return;
                }
                console.log(`Attempting to connect to: ${targetPeerId}`);
                const conn = peer.connect(targetPeerId, { reliable: true });
                setupConnectionEventHandlers(conn);
                updatePeerList(); // Add to list as "connecting"
            }

            function setupConnectionEventHandlers(conn) {
                conn.on('open', () => {
                    console.log(`Connection established with ${conn.peer}`);
                    connections[conn.peer] = conn;
                    updatePeerList();
                    sendFullLocalStorage(conn);
                });

                conn.on('data', (data) => {
                    console.log(`Data received from ${conn.peer}:`, data);
                    handleReceivedData(data, conn.peer);
                });

                conn.on('close', () => {
                    console.log(`Connection closed with ${conn.peer}`);
                    delete connections[conn.peer];
                    updatePeerList();
                });

                conn.on('error', (err) => {
                    console.error(`Connection error with ${conn.peer}:`, err);
                    // alert(`Connection error with ${conn.peer}: ${err.type || err.message}`);
                    delete connections[conn.peer];
                    updatePeerList();
                });
            }

            function updatePeerList() {
                peerList.innerHTML = '';
                const connectedPeerIds = Object.keys(connections);
                peerCountDisplay.textContent = connectedPeerIds.length;

                if (connectedPeerIds.length === 0) {
                    const li = document.createElement('li');
                    li.textContent = 'No active connections.';
                    li.className = 'no-peers';
                    peerList.appendChild(li);
                    return;
                }

                connectedPeerIds.forEach(peerId => {
                    const conn = connections[peerId];
                    const li = document.createElement('li');
                    li.textContent = peerId;
                    
                    const statusIndicator = document.createElement('span');
                    statusIndicator.className = 'peer-status-indicator';
                    if (conn && conn.open) {
                        statusIndicator.classList.add('peer-connected');
                        li.title = 'Connected';
                    } else {
                        statusIndicator.classList.add('peer-connecting');
                        li.title = 'Connecting...';
                    }
                    li.appendChild(statusIndicator);
                    peerList.appendChild(li);
                });
            }

            // --- Invite Link ---
            function generateInviteLink() {
                if (!myPeerId) return;
                const baseUrl = window.location.origin + window.location.pathname;
                inviteLinkInput.value = `${baseUrl}?connectTo=${myPeerId}`;
            }

            copyInviteLinkButton.addEventListener('click', () => {
                inviteLinkInput.select();
                inviteLinkInput.setSelectionRange(0, 99999); // For mobile devices
                try {
                    document.execCommand('copy');
                    copyStatusMessage.textContent = 'Link copied!';
                    copyStatusMessage.classList.add('visible');
                    setTimeout(() => {
                        copyStatusMessage.classList.remove('visible');
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy link: ', err);
                    copyStatusMessage.textContent = 'Failed to copy!';
                    copyStatusMessage.style.color = 'var(--danger-color)';
                    copyStatusMessage.classList.add('visible');
                     setTimeout(() => {
                        copyStatusMessage.classList.remove('visible');
                        copyStatusMessage.style.color = 'var(--success-color)'; // Reset color
                    }, 2000);
                }
            });

            function checkUrlForAutoConnect() {
                const urlParams = new URLSearchParams(window.location.search);
                const connectToId = urlParams.get('connectTo');
                if (connectToId) {
                    console.log(`Found 'connectTo' URL parameter: ${connectToId}`);
                    const newUrl = window.location.origin + window.location.pathname;
                    window.history.replaceState({}, document.title, newUrl);
                    
                    // Delay connection slightly to ensure our own peer is fully ready
                    setTimeout(() => connectToPeer(connectToId), 1500);
                }
            }

            // --- LocalStorage Syncing ---
            function displayLocalStorage() {
                const items = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const value = localStorage.getItem(key);
                    // Simple JSON.stringify for values to show quotes for strings
                    items.push(`  "${key}": ${JSON.stringify(value)}`);
                }
                localStorageDisplay.textContent = items.length > 0 ? `{\n${items.join(',\n')}\n}` : '{}';
            }

            function broadcastStorageChange(change) {
                if (applyingRemoteChange) {
                    // console.log("Skipping broadcast, change was remote or part of initial full sync.");
                    return;
                }
                console.log('Broadcasting change:', change);
                const message = { type: 'localStorageUpdate', ...change };
                Object.values(connections).forEach(conn => {
                    if (conn && conn.open) {
                        try {
                            conn.send(message);
                        } catch (e) {
                            console.error(`Error sending data to ${conn.peer}:`, e);
                            // Optionally handle connection issues here, e.g., mark peer as problematic
                        }
                    }
                });
            }

            function sendFullLocalStorage(conn) {
                const allItems = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    allItems[key] = localStorage.getItem(key);
                }
                console.log(`Sending full localStorage to ${conn.peer}:`, allItems);
                if (conn && conn.open) {
                    conn.send({ type: 'fullLocalStorageSync', data: allItems });
                }
            }

            function handleReceivedData(data, fromPeerId) {
                applyingRemoteChange = true; // Set flag before making changes
                try {
                    if (data.type === 'localStorageUpdate') {
                        console.log(`Applying remote localStorage update from ${fromPeerId}:`, data);
                        if (data.action === 'setItem') {
                            originalSetItem.call(localStorage, data.key, data.value);
                        } else if (data.action === 'removeItem') {
                            originalRemoveItem.call(localStorage, data.key);
                        } else if (data.action === 'clear') {
                            originalClear.call(localStorage);
                        }
                        displayLocalStorage(); // Update display after local change
                    } else if (data.type === 'fullLocalStorageSync') {
                        console.log(`Applying full localStorage sync from ${fromPeerId}:`, data.data);
                        originalClear.call(localStorage); // Clear existing before applying full sync
                        for (const key in data.data) {
                            if (Object.hasOwnProperty.call(data.data, key)) {
                                originalSetItem.call(localStorage, key, data.data[key]);
                            }
                        }
                        displayLocalStorage(); // Update display after local change
                    }
                } catch (e) {
                    console.error("Error applying remote change:", e);
                } finally {
                    applyingRemoteChange = false; // Reset flag
                }
            }

            // Store original localStorage methods
            const originalSetItem = localStorage.setItem;
            const originalRemoveItem = localStorage.removeItem;
            const originalClear = localStorage.clear;

            // Override localStorage methods to detect changes
            localStorage.setItem = function(key, value) {
                const oldValue = localStorage.getItem(key); // Get old value using original getItem
                originalSetItem.call(localStorage, key, value); // Call original method
                if (String(oldValue) !== String(value)) { // Only broadcast if value actually changed
                    broadcastStorageChange({ action: 'setItem', key, value });
                }
                if (!applyingRemoteChange) displayLocalStorage(); // Update local display if not a remote change
            };

            localStorage.removeItem = function(key) {
                const oldValue = localStorage.getItem(key);
                originalRemoveItem.call(localStorage, key);
                if (oldValue !== null) { // Only broadcast if item existed
                    broadcastStorageChange({ action: 'removeItem', key });
                }
                 if (!applyingRemoteChange) displayLocalStorage();
            };

            localStorage.clear = function() {
                const hadItems = localStorage.length > 0;
                originalClear.call(localStorage);
                if (hadItems) { // Only broadcast if there was something to clear
                    broadcastStorageChange({ action: 'clear' });
                }
                if (!applyingRemoteChange) displayLocalStorage();
            };

            // Event listeners for UI controls
            lsSetButton.addEventListener('click', () => {
                const key = lsKeyInput.value.trim();
                const value = lsValueInput.value;
                if (key) {
                    localStorage.setItem(key, value); // Our overridden setItem will handle broadcast & display
                    lsKeyInput.value = '';
                    lsValueInput.value = '';
                } else {
                    alert('Key cannot be empty.');
                }
            });

            lsRemoveButton.addEventListener('click', () => {
                const key = lsKeyInput.value.trim();
                if (key) {
                    localStorage.removeItem(key); // Our overridden removeItem will handle broadcast & display
                    lsKeyInput.value = '';
                    lsValueInput.value = '';
                } else {
                    alert('Key cannot be empty to remove.');
                }
            });

            lsClearButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to clear ALL your local storage items and broadcast this?')) {
                    localStorage.clear(); // Our overridden clear will handle broadcast & display
                }
            });

            // --- Initial Setup ---
            displayLocalStorage(); // Initial display
            initializePeer();      // Start PeerJS
            updatePeerList();      // Initial peer list (empty)

            // Optional: Listen to 'storage' event for changes from other tabs (same origin)
            // This can be complex to integrate perfectly with the override system to avoid loops.
            // window.addEventListener('storage', (event) => {
            //     if (applyingRemoteChange) return; // Avoid processing changes we just applied
            //     console.log('Storage event from another tab/window:', event);
            //
            //     // This change originated outside our current tab's direct localStorage.* calls.
            //     // We need to reflect it in our UI and broadcast it.
            //     displayLocalStorage(); // Update UI
            //
            //     // Determine what happened and broadcast
            //     if (event.key === null) { // localStorage.clear() was called
            //         broadcastStorageChange({ action: 'clear' });
            //     } else if (event.newValue === null) { // localStorage.removeItem(event.key)
            //         broadcastStorageChange({ action: 'removeItem', key: event.key });
            //     } else { // localStorage.setItem(event.key, event.newValue)
            //         broadcastStorageChange({ action: 'setItem', key: event.key, value: event.newValue });
            //     }
            // });
        });
    </script>
</body>
</html>
