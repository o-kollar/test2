<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat (simple-peer)</title>
    <!-- Get simple-peer from a CDN -->
    <script src="https://bundle.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f0f0f0; display: flex; flex-direction: column; align-items: center; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); width: 90%; max-width: 600px; }
        #sessionControls button { margin: 5px; padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        #shareableUrl { margin-top: 10px; padding: 10px; background: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; word-break: break-all; }
        #chatBox { border: 1px solid #ccc; height: 300px; overflow-y: scroll; padding: 10px; margin-bottom: 10px; background: #f8f9fa; }
        .message { margin-bottom: 5px; padding: 8px; border-radius: 5px; max-width: 75%; word-wrap: break-word; }
        .sent { background-color: #d1ecf1; text-align: right; margin-left: auto; }
        .received { background-color: #e2e3e5; text-align: left; margin-right: auto; }
        #messageInput { width: calc(100% - 85px); padding: 10px; border: 1px solid #ccc; border-radius: 4px 0 0 4px; }
        #sendButton { padding: 10px 15px; background-color: #28a745; color: white; border: none; border-radius: 0 4px 4px 0; cursor: pointer; }
        #sendButton:disabled { background-color: #aaa; }
        #status { margin-top: 10px; font-style: italic; color: #555; text-align: center; }
        #chatArea { display: none; margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>P2P Chat with simple-peer</h1>
        <div id="sessionControls">
            <button id="createSessionBtn">Create New Session & Share URL</button>
            <p>Or join if URL has a session ID.</p>
        </div>
        <div id="shareableUrl" style="display:none;">Share this URL: <span></span></div>
        <div id="status">Initializing...</div>

        <div id="chatArea">
            <div id="chatBox"></div>
            <input type="text" id="messageInput" placeholder="Type a message..." disabled>
            <button id="sendButton" disabled>Send</button>
        </div>
    </div>

    <script>
        const createSessionBtn = document.getElementById('createSessionBtn');
        const shareableUrlDiv = document.getElementById('shareableUrl');
        const shareableUrlSpan = shareableUrlDiv.querySelector('span');
        const statusDiv = document.getElementById('status');
        const chatArea = document.getElementById('chatArea');
        const chatBox = document.getElementById('chatBox');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');

        let peer;
        let roomId = null;

        function logStatus(message) {
            console.log(message);
            statusDiv.textContent = message;
        }

        function generateRoomId() {
            return 'p2pchat-' + Math.random().toString(36).substring(2, 9); // Prefix to avoid collisions
        }

        createSessionBtn.onclick = () => {
            roomId = generateRoomId();
            window.location.hash = roomId;
            shareableUrlSpan.textContent = window.location.href;
            shareableUrlDiv.style.display = 'block';
            createSessionBtn.disabled = true;
            logStatus(`Session created. Room ID: ${roomId}. Share the URL.`);
            startP2PConnection(true); // true for initiator
        };

        function initializeApp() {
            if (window.location.hash) {
                roomId = window.location.hash.substring(1);
                logStatus(`Joining room: ${roomId}`);
                shareableUrlSpan.textContent = window.location.href;
                shareableUrlDiv.style.display = 'block';
                createSessionBtn.style.display = 'none';
                startP2PConnection(false); // false for joiner
            } else {
                logStatus('Ready. Create a session or open a session URL.');
            }
        }

        function startP2PConnection(isInitiator) {
            if (!roomId) {
                logStatus("Error: No Room ID.");
                return;
            }

            logStatus(isInitiator ? 'Initiating connection...' : 'Attempting to join...');

            // simple-peer will use its default public STUN servers and trackers
            // For specific trackers: peer = new SimplePeer({ initiator: isInitiator, trickle: false, config: { iceServers: [...] }, wrtc: wrtc })
            // trickle: false can sometimes be easier for initial setup as it bundles candidates.
            peer = new SimplePeer({
                initiator: isInitiator,
                trickle: false, // Bundles ICE candidates into SDP, simpler signaling
                // config: { iceServers: [ { urls: 'stun:stun.l.google.com:19302' } ] } // Already uses defaults
            });

            peer.on('error', err => {
                console.error('Peer error:', err);
                logStatus(`Connection Error: ${err.message}. Try refreshing.`);
                if (peer) peer.destroy();
            });

            peer.on('signal', data => {
                // This is where simple-peer gives you signaling data (offer/answer/candidate)
                // In a "no backend" scenario, if we weren't using trackers implicitly,
                // this 'data' would need to be manually exchanged.
                // With trackers, simple-peer handles this exchange if both peers use the same 'room'
                // concept, which we are faking by having them connect *to each other* and
                // simple-peer does the handshake automatically.
                //
                // For a URL-based "room" without explicit server signaling:
                // Initiator gets offer -> puts in URL -> Joiner gets offer from URL -> generates answer -> puts in new URL -> Initiator gets answer from new URL
                //
                // If using simple-peer with a custom signaling server (not what we want here):
                // signalingSocket.send(JSON.stringify({ type: 'signal', signal: data, toRoom: roomId }));
                //
                // For this example to work with URL-based signaling via hash:
                // Peer 1 (initiator) generates offer, puts in hash.
                // Peer 2 sees hash, takes offer, generates answer, signals it back by changing hash.
                // Peer 1 sees hash change, takes answer.
                // This is what we'll do: encode the signal data in the hash for the other peer to pick up.

                if (isInitiator && data.type === 'offer') {
                    // Initiator: Offer is ready. Put it in a URL for Peer 2.
                    const offerSignal = encodeURIComponent(JSON.stringify(data));
                    const fullUrl = `${window.location.origin}${window.location.pathname}#${roomId}&offer=${offerSignal}`;
                    shareableUrlSpan.textContent = fullUrl; // Update the shareable URL
                    window.history.replaceState(null, '', `#${roomId}&offer=${offerSignal}`); // Update current URL
                    logStatus('Offer generated. Share the updated URL. Waiting for answer...');
                } else if (!isInitiator && data.type === 'answer') {
                    // Joiner: Answer is ready. Put it in a URL for Peer 1.
                    const answerSignal = encodeURIComponent(JSON.stringify(data));
                    // The original URL Peer 2 opened had Peer 1's offer.
                    // Peer 1 is waiting for an answer related to its original room and offer.
                    // Peer 1's page should detect this answer in its hash.
                    const params = new URLSearchParams(window.location.hash.substring(1));
                    const originalRoom = params.get('room'); // Or the first part of the hash
                    const answerUrlFragment = `#${originalRoom}&answer=${answerSignal}`; // Use original room ID
                    window.location.hash = answerUrlFragment; // This change should be detected by Peer 1
                    logStatus('Answer generated and put in URL hash for Peer 1 to see. Waiting for connection...');
                }
            });


            peer.on('connect', () => {
                logStatus('P2P Connection Established!');
                chatArea.style.display = 'block';
                messageInput.disabled = false;
                sendButton.disabled = false;
                shareableUrlDiv.style.display = 'none'; // Hide URL sharing once connected
                sessionControls.style.display = 'none';
            });

            peer.on('data', data => {
                appendMessage(data.toString(), 'received');
            });

            peer.on('close', () => {
                logStatus('Connection closed. Please refresh to start over.');
                if (peer) peer.destroy();
                chatArea.style.display = 'none';
                messageInput.disabled = true;
                sendButton.disabled = true;
                sessionControls.style.display = 'block';
                createSessionBtn.disabled = false;
                createSessionBtn.style.display = 'inline-block';
            });

            // Check hash for incoming signals (offer for joiner, answer for initiator)
            handleUrlSignal(); // Initial check
            window.addEventListener('hashchange', handleUrlSignal);
        }

        function handleUrlSignal() {
            if (!peer || peer.destroyed) return; // Don't process if peer isn't ready or is destroyed

            const hashContent = window.location.hash.substring(1);
            const params = new URLSearchParams(hashContent.includes('&') ? hashContent.substring(hashContent.indexOf('&')+1) : '');

            if (params.has('offer') && !peer.initiator && !peer.destroyed) { // Joiner receives offer
                try {
                    const offerSignal = JSON.parse(decodeURIComponent(params.get('offer')));
                    if (offerSignal.type === 'offer') {
                        peer.signal(offerSignal);
                        logStatus('Received offer from URL, signaling answer...');
                        // Clear the offer from hash after processing to prevent re-processing
                        // window.history.replaceState(null, '', `#${roomId}`);
                    }
                } catch (e) { console.error("Error parsing offer from URL:", e); }
            } else if (params.has('answer') && peer.initiator && !peer.destroyed) { // Initiator receives answer
                try {
                    const answerSignal = JSON.parse(decodeURIComponent(params.get('answer')));
                    if (answerSignal.type === 'answer') {
                        peer.signal(answerSignal);
                        logStatus('Received answer from URL, attempting to connect...');
                        // Clear the answer from hash
                        // window.history.replaceState(null, '', `#${roomId}`);
                    }
                } catch (e) { console.error("Error parsing answer from URL:", e); }
            }
        }


        sendButton.onclick = () => {
            const message = messageInput.value;
            if (message && peer && !peer.destroyed) {
                peer.send(message);
                appendMessage(message, 'sent');
                messageInput.value = '';
            }
        };

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendButton.click();
        });

        function appendMessage(message, type) {
            const msgDiv = document.createElement('div');
            msgDiv.classList.add('message', type);
            msgDiv.textContent = message; // Use textContent for security
            chatBox.appendChild(msgDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        initializeApp();
    </script>
</body>
</html>
