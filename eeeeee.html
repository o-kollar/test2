<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MoE-minGRU Visualizer (Full Spec)</title>
    <style>
        :root {
            --bg: #121212;
            --surface: #1e1e1e;
            --surface-dark: #161616;
            --primary: #bb86fc;
            --primary-dim: #372847;
            --text: #e0e0e0;
            --text-dim: #aaa;
            --border: #333;
            --accent: #03dac6;
            --danger: #cf6679;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .panel {
            background: var(--surface);
            padding: 20px;
            border-radius: 16px;
            border: 2px solid var(--border);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3), 0 1px 3px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 15px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px rgba(0,0,0,0.4), 0 2px 4px rgba(0,0,0,0.3);
        }

        h2 {
            margin: 0;
            font-size: 1.3rem;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--border);
            color: var(--primary);
        }

        .status-dot {
            height: 10px;
            width: 10px;
            background-color: #555;
            border-radius: 50%;
            display: inline-block;
        }
        .status-dot.active { background-color: var(--accent); box-shadow: 0 0 8px var(--accent); }

        /* Controls */
        .controls-row {
            display: flex;
            gap: 10px;
        }
        button {
            flex: 1;
            background: var(--primary);
            color: #000;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        button:hover { 
            opacity: 0.9; 
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        button:disabled { background: #444; color: #888; cursor: not-allowed; box-shadow: none; transform: none; }
        button.stop { background: var(--danger); color: white; }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            background: rgba(0,0,0,0.3);
            padding: 16px;
            border-radius: 10px;
            font-size: 0.85rem;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .config-item { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 6px;
        }
        .config-item label {
            color: var(--text-dim);
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        input[type=number] {
            background: rgba(255,255,255,0.05);
            border: 1px solid #555;
            border-radius: 6px;
            color: var(--accent);
            width: 100%;
            text-align: center;
            font-size: 0.95rem;
            padding: 6px;
            transition: all 0.2s ease;
        }
        input[type=number]:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(3, 218, 198, 0.1);
        }

        /* --- ACCORDION STYLES --- */
        .accordion-header {
            background-color: #2a2a2a;
            color: var(--text);
            cursor: pointer;
            padding: 16px;
            width: 100%;
            border: 2px solid var(--border);
            text-align: left;
            outline: none;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .accordion-header:hover { 
            background-color: #333;
            transform: translateX(4px);
        }

        .accordion-header.active {
            background-color: var(--primary-dim);
            color: var(--primary);
            border-color: var(--primary);
            border-bottom-right-radius: 0;
            border-bottom-left-radius: 0;
            margin-bottom: 0;
            box-shadow: 0 4px 8px rgba(187, 134, 252, 0.2);
        }

        .accordion-header:after { content: '+'; font-size: 1.4rem; line-height: 1rem; font-weight: 300; }
        .accordion-header.active:after { content: '‚àí'; }

        .accordion-content {
            padding: 0 16px;
            background-color: var(--surface-dark);
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            border: 2px solid var(--border);
            border-top: none;
            border-radius: 0 0 12px 12px;
            opacity: 0;
            margin-bottom: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .accordion-content.show { 
            opacity: 1; 
            padding-bottom: 16px; 
            padding-top: 16px; 
        }

        /* Visualization Area */
        .viz-container {
            background: #000;
            border-radius: 12px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            min-height: 300px;
            border: 2px solid #222;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        .chart-label { 
            font-size: 0.8rem; 
            color: #999; 
            text-transform: uppercase; 
            letter-spacing: 1.5px; 
            font-weight: 600;
            margin-bottom: 4px;
        }

        /* Loss Graph */
        canvas#lossGraph {
            width: 100%;
            height: 120px;
            border-bottom: 1px solid #333;
        }

        /* Expert Bars */
        .experts-wrapper {
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex: 1;
        }
        .bars-container {
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            height: 100px;
            gap: 4px;
            padding-top: 10px;
        }
        .expert-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            height: 100%;
            justify-content: flex-end;
        }
        .bar {
            width: 100%;
            background: var(--primary-dim);
            border-top: 2px solid var(--primary);
            transition: height 0.2s ease;
            min-height: 2px;
            border-radius: 2px 2px 0 0;
            opacity: 0.7;
        }
        .bar.active { opacity: 1; background: var(--primary); }
        .x-label { font-size: 0.6rem; color: #666; text-align:center; }

        /* Data Input */
        textarea.data-input {
            width: 100%;
            height: 200px;
            background: #0d0d0d;
            color: #999;
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            font-family: monospace;
            font-size: 13px;
            resize: vertical;
            box-sizing: border-box;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
            transition: border-color 0.2s ease;
        }
        textarea.data-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Output / Terminal Area */
        .output-area {
            min-height: 200px;
            background: #0d0d0d;
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            overflow-y: auto;
            font-family: "Courier New", Courier, monospace;
            color: #d1c4e9;
            white-space: pre-wrap;
            font-size: 0.95rem;
            line-height: 1.6;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .input-bar { display: flex; gap: 10px; }
        input[type=text] {
            flex: 1; 
            background: #222; 
            border: 2px solid #444; 
            color: white;
            padding: 12px 16px; 
            border-radius: 8px; 
            outline: none;
            font-size: 0.95rem;
            transition: all 0.2s ease;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2);
        }
        input[type=text]:focus { 
            border-color: var(--accent);
            background: #2a2a2a;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.2), 0 0 0 3px rgba(3, 218, 198, 0.1);
        }

    </style>
</head>
<body>

<div class="container">
    
    <!-- Block 1: Training Controls -->
    <div class="panel">
        <h2>
            Training Controls
            <span id="status-indicator" class="status-dot"></span>
        </h2>
        
        <div class="controls-row">
            <button id="btnTrain">Start Training</button>
            <button id="btnStop" class="stop" disabled>Stop</button>
        </div>

        <div class="config-grid">
            <div class="config-item"><label>Dim</label><input type="number" id="hiddenSize" value="64"></div>
            <div class="config-item"><label>Max LR</label><input type="number" id="learnRate" value="0.003" step="0.0001"></div>
            <div class="config-item"><label>Experts</label><input type="number" id="numExperts" value="8"></div>
            <div class="config-item"><label>Top-K</label><input type="number" id="topK" value="2"></div>
            <div class="config-item"><label>Batch Size</label><input type="number" id="batchSize" value="8" min="1" title="Gradient accumulation steps"></div>
            <div class="config-item"><label>Œª Bal</label><input type="number" id="lambdaBal" value="0.01" step="0.01"></div>
            <div class="config-item"><label>Œ≥ Ent</label><input type="number" id="gammaEnt" value="0.005" step="0.001"></div>
            <div class="config-item"><label>Warmup</label><input type="number" id="warmupSteps" value="200" title="Warmup iterations"></div>
            <div class="config-item"><label>Decay</label><input type="number" id="decaySteps" value="8000" title="Total training iterations"></div>
        </div>
    </div>

    <!-- Block 2: Visualization -->
    <div class="panel">
        <button class="accordion-header active">üìä Loss & Expert Activity</button>
        <div class="accordion-content show">
            <div class="viz-container">
                <div class="chart-label">Loss Curve (Log Scale)</div>
                <canvas id="lossGraph"></canvas>
                
                <div class="experts-wrapper">
                    <div class="chart-label">Expert Load (Slow ‚Üê ‚Üí Fast)</div>
                    <div id="expertBars" class="bars-container"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Block 3: Training Data -->
    <div class="panel">
        <button class="accordion-header">üìù Training Dataset</button>
        <div class="accordion-content">
            <textarea id="training-data" class="data-input" spellcheck="false">Q: what is the weather in London?
A: GET /weather?q=London
Q: show me weather for Paris
A: GET /weather?q=Paris
Q: Tokyo weather please
A: GET /weather?q=Tokyo
Q: how is the weather in Berlin
A: GET /weather?q=Berlin
Q: check weather Madrid
A: GET /weather?q=Madrid
Q: weather in Rome
A: GET /weather?q=Rome
Q: New York weather status
A: GET /weather?q=New York
Q: what's the forecast for Oslo?
A: GET /forecast?q=Oslo
Q: give me forecast for Cairo
A: GET /forecast?q=Cairo
Q: forecast in Dublin
A: GET /forecast?q=Dublin
Q: is it raining in Seattle?
A: GET /weather?q=Seattle&type=rain
Q: is it sunny in Miami?
A: GET /weather?q=Miami&type=sun
Q: check rain for Portland
A: GET /weather?q=Portland&type=rain
Q: temperature in Chicago
A: GET /weather?q=Chicago&units=metric
Q: how hot is Phoenix?
A: GET /weather?q=Phoenix&units=imperial
Q: weather in Sydney
A: GET /weather?q=Sydney
Q: weather in Moscow
A: GET /weather?q=Moscow
Q: forecast Beijing
A: GET /forecast?q=Beijing
Q: check weather in Toronto
A: GET /weather?q=Toronto
Q: Seoul weather report
A: GET /weather?q=Seoul
Q: weather Mumbai
A: GET /weather?q=Mumbai
Q: forecast for Lima
Q: forecast for Lima</textarea>
        </div>
    </div>

    <!-- Block 4: Inference -->
    <div class="panel">
        <h2>üí¨ Model Inference</h2>
        <div id="output-area" class="output-area">// System ready.
// Train the model, then enter a query below.
</div>
        <div class="input-bar">
            <input type="text" id="user-query" placeholder="e.g. weather in..." autocomplete="off">
            <button id="btnAsk" style="flex:0 0 100px; background: var(--accent); color: #000;">Generate</button>
        </div>
    </div>

</div>

<script type="module">
// ============================================================================
// 1. MATH LIBRARY (Micrograd-ish)
// ============================================================================

const Utils = {
    randf: (a, b) => Math.random() * (b - a) + a,
    zeros: (n) => new Float64Array(n),
    sig: (x) => 1.0 / (1 + Math.exp(-x)),
    softmax: function(w) {
        var out = new Float64Array(w.length), maxval = -Number.MAX_VALUE;
        for (let i = 0; i < w.length; i++) if (w[i] > maxval) maxval = w[i];
        var s = 0.0;
        for (let i = 0; i < w.length; i++) { out[i] = Math.exp(w[i] - maxval); s += out[i]; }
        for (let i = 0; i < w.length; i++) out[i] /= s;
        return out;
    },
    maxi: function(w) {
        let maxv = w[0], maxix = 0;
        for (let i = 1; i < w.length; i++) if (w[i] > maxv) { maxv = w[i]; maxix = i; }
        return maxix;
    },
    topKIndices: function(w, k) {
        let indices = Array.from(w.keys());
        indices.sort((a, b) => w[b] - w[a]);
        return indices.slice(0, k);
    }
};

class Mat {
    constructor(n, d) { this.n = n; this.d = d; this.w = Utils.zeros(n * d); this.dw = Utils.zeros(n * d); }
    get(r, c) { return this.w[this.d * r + c]; }
    set(r, c, v) { this.w[this.d * r + c] = v; }
}

class RandMat extends Mat {
    constructor(n, d, mu, std) {
        super(n, d);
        for (let i = 0; i < this.w.length; i++) this.w[i] = Utils.randf(-std, std);
    }
}

class Graph {
    constructor(needsBackprop = true) { this.needsBackprop = needsBackprop; this.backprop = []; }
    backward() { for (let i = this.backprop.length - 1; i >= 0; i--) this.backprop[i](); }
    
    tanh(m) {
        var out = new Mat(m.n, m.d), n = m.w.length;
        for (let i = 0; i < n; i++) out.w[i] = Math.tanh(m.w[i]);
        if (this.needsBackprop) this.backprop.push(() => {
            for (let i = 0; i < n; i++) m.dw[i] += (1.0 - out.w[i] * out.w[i]) * out.dw[i];
        });
        return out;
    }
    sigmoid(m) {
        var out = new Mat(m.n, m.d), n = m.w.length;
        for (let i = 0; i < n; i++) out.w[i] = Utils.sig(m.w[i]);
        if (this.needsBackprop) this.backprop.push(() => {
            for (let i = 0; i < n; i++) m.dw[i] += out.w[i] * (1.0 - out.w[i]) * out.dw[i];
        });
        return out;
    }
    mul(m1, m2) {
        var n = m1.n, d = m2.d, out = new Mat(n, d);
        for (let i = 0; i < m1.n; i++) {
            for (let j = 0; j < m2.d; j++) {
                var dot = 0.0;
                for (let k = 0; k < m1.d; k++) dot += m1.w[m1.d * i + k] * m2.w[m2.d * k + j];
                out.w[d * i + j] = dot;
            }
        }
        if (this.needsBackprop) this.backprop.push(() => {
            for (let i = 0; i < m1.n; i++) {
                for (let j = 0; j < m2.d; j++) {
                    var b = out.dw[d * i + j];
                    for (let k = 0; k < m1.d; k++) {
                        m1.dw[m1.d * i + k] += m2.w[m2.d * k + j] * b;
                        m2.dw[m2.d * k + j] += m1.w[m1.d * i + k] * b;
                    }
                }
            }
        });
        return out;
    }
    add(m1, m2) {
        var out = new Mat(m1.n, m1.d), n = m1.w.length;
        for (let i = 0; i < n; i++) out.w[i] = m1.w[i] + m2.w[i];
        if (this.needsBackprop) this.backprop.push(() => {
            for (let i = 0; i < n; i++) { m1.dw[i] += out.dw[i]; m2.dw[i] += out.dw[i]; }
        });
        return out;
    }
    eltmul(m1, m2) {
        var out = new Mat(m1.n, m1.d), n = m1.w.length;
        for (let i = 0; i < n; i++) out.w[i] = m1.w[i] * m2.w[i];
        if (this.needsBackprop) this.backprop.push(() => {
            for (let i = 0; i < n; i++) { m1.dw[i] += m2.w[i] * out.dw[i]; m2.dw[i] += m1.w[i] * out.dw[i]; }
        });
        return out;
    }
    softmaxMat(m) {
        var out = new Mat(m.n, m.d);
        var sm = Utils.softmax(m.w);
        for(let i=0; i<sm.length; i++) out.w[i] = sm[i];
        if (this.needsBackprop) this.backprop.push(() => {
            // Correct softmax backward: dL/dlogit_i = Œ£_j [dL/dout_j * ‚àÇout_j/‚àÇlogit_i]
            // Where: ‚àÇout_j/‚àÇlogit_i = out_j * (Œ¥_ij - out_i)
            for(let i=0; i<m.n; i++) {
                let grad = 0;
                for(let j=0; j<m.n; j++) {
                    if(i === j) {
                        // ‚àÇout_i/‚àÇlogit_i = out_i * (1 - out_i)
                        grad += out.w[i] * (1 - out.w[i]) * out.dw[i];
                    } else {
                        // ‚àÇout_j/‚àÇlogit_i = -out_j * out_i
                        grad += -out.w[j] * out.w[i] * out.dw[j];
                    }
                }
                // Clamp gradient to prevent explosion
                if (grad > 10) grad = 10;
                else if (grad < -10) grad = -10;
                m.dw[i] += grad;
            }
        });
        return out;
    }
    oneMinus(m) {
        var out = new Mat(m.n, m.d), n = m.w.length;
        for (let i = 0; i < n; i++) out.w[i] = 1.0 - m.w[i];
        if (this.needsBackprop) this.backprop.push(() => {
            for (let i = 0; i < n; i++) m.dw[i] -= out.dw[i];
        });
        return out;
    }
    gelu(m) {
        var out = new Mat(m.n, m.d), n = m.w.length;
        const sqrt2OverPi = Math.sqrt(2.0 / Math.PI);
        for (let i = 0; i < n; i++) {
            const x = m.w[i];
            const cdf = 0.5 * (1.0 + Math.tanh(sqrt2OverPi * (x + 0.044715 * x * x * x)));
            out.w[i] = x * cdf;
        }
        if (this.needsBackprop) this.backprop.push(() => {
            for (let i = 0; i < n; i++) {
                const x = m.w[i];
                const tanh_arg = sqrt2OverPi * (x + 0.044715 * x * x * x);
                const tanh_out = Math.tanh(tanh_arg);
                const cdf = 0.5 * (1.0 + tanh_out);
                const pdf = sqrt2OverPi * 0.5 * (1 - tanh_out * tanh_out) * (1 + 3 * 0.044715 * x * x);
                let grad = (cdf + x * pdf) * out.dw[i];
                // Clamp gradient to prevent explosion
                if (grad > 10) grad = 10;
                else if (grad < -10) grad = -10;
                m.dw[i] += grad;
            }
        });
        return out;
    }
    rowSlice(m, rowIndex) {
        var d = m.d;
        var out = new Mat(1, d);
        for(let i=0; i<d; i++) out.w[i] = m.w[d*rowIndex + i];
        if(this.needsBackprop) this.backprop.push(() => {
            for(let i=0; i<d; i++) m.dw[d*rowIndex + i] += out.dw[i];
        });
        return out;
    }
}

class Solver {
    constructor() {
        this.m = new Map(); this.v = new Map(); this.t = 0;
        this.beta1 = 0.9; this.beta2 = 0.999; this.eps = 1e-8;
    }
    step(model, lr, wd, clip) {
        this.t++;
        const c1 = 1.0 - Math.pow(this.beta1, this.t);
        const c2 = 1.0 - Math.pow(this.beta2, this.t);
        for (const k in model) {
            if (Object.prototype.hasOwnProperty.call(model, k)) {
                const mat = model[k];
                if (!this.m.has(k)) { this.m.set(k, new Float64Array(mat.w.length)); this.v.set(k, new Float64Array(mat.w.length)); }
                const m = this.m.get(k), v = this.v.get(k);
                for (let i = 0, n = mat.w.length; i < n; i++) {
                    let g = mat.dw[i];
                    if (g > clip) g = clip; else if (g < -clip) g = -clip;
                    
                    // Update biased first and second moments
                    m[i] = this.beta1 * m[i] + (1.0 - this.beta1) * g;
                    v[i] = this.beta2 * v[i] + (1.0 - this.beta2) * g * g;
                    
                    // Bias-corrected moments
                    const m_hat = m[i] / c1;
                    const v_hat = v[i] / c2;
                    
                    // AdamW: Apply weight decay directly to weights (decoupled)
                    if (wd > 0) mat.w[i] *= (1.0 - lr * wd);
                    
                    // Adam update with bias-corrected moments
                    mat.w[i] -= lr * m_hat / (Math.sqrt(v_hat) + this.eps);
                    mat.dw[i] = 0;
                }
            }
        }
    }
}

// ============================================================================
// 2. MOE-minGRU (With State Coupling, Time-Scale Init, Concatenated Router)
// ============================================================================

function lookupEmbedding(G, embedMatrix, charIndex) {
    // Extract embedding row for given character index
    var embSize = embedMatrix.d;
    var out = new Mat(embSize, 1);
    
    // Forward: copy the embedding
    for(let i = 0; i < embSize; i++) {
        out.w[i] = embedMatrix.w[charIndex * embSize + i];
    }
    
    // Backward: accumulate gradient to the embedding
    if(G.needsBackprop) {
        G.backprop.push(() => {
            for(let i = 0; i < embSize; i++) {
                let grad = out.dw[i];
                // Clamp gradient to prevent explosion
                if (grad > 5) grad = 5;
                else if (grad < -5) grad = -5;
                embedMatrix.dw[charIndex * embSize + i] += grad;
            }
        });
    }
    
    return out;
}

function rmsnorm(G, x, scale, eps = 1e-5) {
    // RMSNorm: normalize by root mean square, then scale
    var n = x.w.length;
    var out = new Mat(x.n, x.d);
    
    // Compute RMS
    var sumSquares = 0.0;
    for(let i = 0; i < n; i++) {
        sumSquares += x.w[i] * x.w[i];
    }
    var rms = Math.sqrt(sumSquares / n + eps);
    
    // Normalize and scale
    for(let i = 0; i < n; i++) {
        out.w[i] = (x.w[i] / rms) * scale.w[i];
    }
    
    // Backward pass
    if(G.needsBackprop) {
        G.backprop.push(() => {
            var sumSquares = 0.0;
            for(let i = 0; i < n; i++) {
                sumSquares += x.w[i] * x.w[i];
            }
            var rms = Math.sqrt(sumSquares / n + eps);
            
            // Gradient through scale (with clamping)
            for(let i = 0; i < n; i++) {
                let grad = out.dw[i] * (x.w[i] / rms);
                if (grad > 10) grad = 10;
                else if (grad < -10) grad = -10;
                scale.dw[i] += grad;
            }
            
            // Gradient through normalization
            var sumGradNorm = 0.0;
            for(let i = 0; i < n; i++) {
                sumGradNorm += out.dw[i] * scale.w[i] * x.w[i];
            }
            
            for(let i = 0; i < n; i++) {
                var norm = x.w[i] / rms;
                let grad = (out.dw[i] * scale.w[i] / rms) - (norm * sumGradNorm / (n * rms * rms));
                // Clamp gradient
                if (grad > 10) grad = 10;
                else if (grad < -10) grad = -10;
                x.dw[i] += grad;
            }
        });
    }
    
    return out;
}

function initMoEGRU(vocabSize, embeddingSize, hiddenSize, outputSize, numExperts, topK) {
    var model = {};
    
    // Embedding Layer: vocab_size x embedding_size
    model['W_embed'] = new RandMat(vocabSize, embeddingSize, 0, 0.08);
    
    // RMSNorm scale parameters for embedding
    model['embed_scale'] = new Mat(embeddingSize, 1);
    for(let i = 0; i < embeddingSize; i++) model['embed_scale'].w[i] = 1.0;
    
    // Embedding projection for residual connection (if embedding != hidden size)
    if (embeddingSize !== hiddenSize) {
        model['emb_proj'] = new RandMat(hiddenSize, embeddingSize, 0, 0.08);
    }
    
    // UPDATED: Router now takes [emb; h_prev] so dimension is embeddingSize + hiddenSize
    model['W_router'] = new RandMat(numExperts, embeddingSize + hiddenSize, 0, 0.02);
    
    for(let e = 0; e < numExperts; e++) {
        // --- STANDARD WEIGHTS ---
        model[`E${e}_Wz`] = new RandMat(hiddenSize, embeddingSize, 0, 0.05); // Embedding -> Update
        model[`E${e}_Wh`] = new RandMat(hiddenSize, embeddingSize, 0, 0.05); // Embedding -> Candidate
        
        // --- RECURRENCE WEIGHTS (Coupling) ---
        model[`E${e}_Uz`] = new RandMat(hiddenSize, hiddenSize, 0, 0.02); // State -> Update
        model[`E${e}_Uh`] = new RandMat(hiddenSize, hiddenSize, 0, 0.02); // State -> Candidate
        
        // --- LEARNABLE TIME SCALE SPECIALIZATION ---
        // Initialize with time-scale hint: -1.5 (Slow/Memory) to +1.5 (Fast/Reactive)
        // But allow gradient updates to refine specialization
        let timeScaleBias = -1.5 + (e / Math.max(1, numExperts - 1)) * 3.0;
        
        model[`E${e}_bz`] = new RandMat(hiddenSize, 1, 0, 0.05);
        for(let k=0; k<hiddenSize; k++) model[`E${e}_bz`].w[k] += timeScaleBias;

        model[`E${e}_bh`] = new RandMat(hiddenSize, 1, 0, 0.05);
    }
    
    // MLP Layer (hiddenSize -> 4*hiddenSize -> hiddenSize)
    const mlpHiddenSize = hiddenSize * 4;
    model['W_mlp1'] = new RandMat(mlpHiddenSize, hiddenSize, 0, Math.sqrt(2.0 / hiddenSize));
    model['b_mlp1'] = new Mat(mlpHiddenSize, 1);
    model['W_mlp2'] = new RandMat(hiddenSize, mlpHiddenSize, 0, Math.sqrt(2.0 / mlpHiddenSize));
    model['b_mlp2'] = new Mat(hiddenSize, 1);
    
    // Output Head
    model['Whd'] = new RandMat(outputSize, hiddenSize, 0, 0.02);
    model['bd'] = new Mat(outputSize, 1);
    
    return model;
}

function forwardMoEGRU(G, model, hiddenSize, numExperts, topK, charIndex, prev) {
    // Lookup embedding for input character
    let emb = lookupEmbedding(G, model['W_embed'], charIndex);
    
    // Apply RMSNorm to embedding
    emb = rmsnorm(G, emb, model['embed_scale']);
    
    // RESIDUAL PATH: Save normalized embedding for skip connection
    let emb_residual = emb;
    
    // Ensure h_prev exists
    let h_prev = (prev && prev.h) ? prev.h : new Mat(hiddenSize, 1);

    // --- CONCATENATION [emb; h_prev] for Router ---
    let routerInput = new Mat(emb.n + h_prev.n, 1);
    
    // Forward Copy
    for(let i=0; i<emb.n; i++) routerInput.w[i] = emb.w[i];
    for(let i=0; i<h_prev.n; i++) routerInput.w[emb.n + i] = h_prev.w[i];

    // Backward Connection
    if(G.needsBackprop) {
        G.backprop.push(() => {
            for(let i=0; i<emb.n; i++) emb.dw[i] += routerInput.dw[i];
            for(let i=0; i<h_prev.n; i++) h_prev.dw[i] += routerInput.dw[emb.n + i];
        });
    }

    // 1. Router (Uses Concatenated Input)
    const routerLogitsFull = G.mul(model['W_router'], routerInput);
    
    // Track dense probs for Load Balancing
    const denseProbs = G.softmaxMat(routerLogitsFull);
    const indices = Utils.topKIndices(routerLogitsFull.w, topK);
    
    // 2. Softmax for chosen experts
    let selectedLogits = new Mat(topK, 1);
    for(let i=0; i<topK; i++) {
        const row = G.rowSlice(model['W_router'], indices[i]); 
        const logit = G.mul(row, routerInput); // Route on [emb; h]
        selectedLogits.w[i] = logit.w[0];
        if (G.needsBackprop) G.backprop.push(() => { logit.dw[0] += selectedLogits.dw[i]; });
    }
    const routingWeights = G.softmaxMat(selectedLogits);
    
    // 3. Experts Execution
    let final_h = new Mat(hiddenSize, 1);

    for(let i=0; i<topK; i++) {
        let expertIdx = indices[i];
        let weight = routingWeights.w[i];

        // Recurrence & Time-Scale Logic
        // z = sigmoid(Wz*emb + Uz*h + bz_specialized)
        let z_sum = G.add(G.add(G.mul(model[`E${expertIdx}_Wz`], emb), G.mul(model[`E${expertIdx}_Uz`], h_prev)), model[`E${expertIdx}_bz`]);
        let z = G.sigmoid(z_sum);
        
        // hTilde = tanh(Wh*emb + Uh*h + bh)
        let h_sum = G.add(G.add(G.mul(model[`E${expertIdx}_Wh`], emb), G.mul(model[`E${expertIdx}_Uh`], h_prev)), model[`E${expertIdx}_bh`]);
        let hTilde = G.tanh(h_sum);
        
        // GRU Update
        let h_expert = G.add(G.eltmul(G.oneMinus(z), h_prev), G.eltmul(z, hTilde));

        let weightMat = new Mat(hiddenSize, 1);
        for(let k=0; k<hiddenSize; k++) weightMat.w[k] = weight;
        
        if (G.needsBackprop) G.backprop.push(() => {
             let sum = 0; for(let k=0; k<hiddenSize; k++) sum += weightMat.dw[k];
             routingWeights.dw[i] += sum;
        });

        final_h = G.add(final_h, G.eltmul(weightMat, h_expert));
    }
    
    // RESIDUAL: Combine normalized embedding with MoE output
    // Need to project embedding to hidden size if dimensions differ
    let emb_projected = emb_residual;
    if (emb_residual.n !== hiddenSize) {
        // Project embedding to hidden dimension
        emb_projected = G.mul(model['emb_proj'], emb_residual);
    }
    let h_combined = G.add(final_h, emb_projected);
    
    // MLP Layer with GELU activation
    let mlp1 = G.add(G.mul(model['W_mlp1'], h_combined), model['b_mlp1']);
    let mlp1_act = G.gelu(mlp1);
    let h_with_mlp = G.add(G.mul(model['W_mlp2'], mlp1_act), model['b_mlp2']);
    
    var output = G.add(G.mul(model['Whd'], h_with_mlp), model['bd']);
    return { h: h_with_mlp, o: output, indices: indices, denseProbs: denseProbs };
}

// ============================================================================
// 3. APP LOGIC & VISUALIZATION
// ============================================================================

const els = {
    input: document.getElementById('training-data'),
    outputArea: document.getElementById('output-area'),
    userQuery: document.getElementById('user-query'),
    btnAsk: document.getElementById('btnAsk'),
    btnTrain: document.getElementById('btnTrain'),
    btnStop: document.getElementById('btnStop'),
    hiddenSize: document.getElementById('hiddenSize'),
    learnRate: document.getElementById('learnRate'),
    numExperts: document.getElementById('numExperts'),
    topK: document.getElementById('topK'),
    batchSize: document.getElementById('batchSize'),
    lambdaBal: document.getElementById('lambdaBal'),
    gammaEnt: document.getElementById('gammaEnt'),
    warmupSteps: document.getElementById('warmupSteps'),
    decaySteps: document.getElementById('decaySteps'),
    status: document.getElementById('status-indicator'),
    lossCanvas: document.getElementById('lossGraph'),
    expertBars: document.getElementById('expertBars')
};

let model, solver, vocab, charToIx, ixToChar;
let isTraining = false, dataIdx = 0, epoch = 0, iter = 0, smoothLoss = 1.0;
let lossHistory = [];
let expertUsage = [];
let batchAccumCount = 0;

function initModel() {
    const text = els.input.value;
    const chars = [...new Set(text)].sort();
    if(!chars.includes('\n')) chars.push('\n');
    vocab = chars;
    charToIx = {}; ixToChar = {};
    chars.forEach((c, i) => { charToIx[c] = i; ixToChar[i] = c; });

    const hSize = parseInt(els.hiddenSize.value);
    const nExp = parseInt(els.numExperts.value);
    const topK = parseInt(els.topK.value);
    const embSize = Math.max(16, Math.floor(hSize / 2)); // Embedding size proportional to hidden size

    model = initMoEGRU(chars.length, embSize, hSize, chars.length, nExp, topK);
    solver = new Solver();
    
    // Reset Stats
    dataIdx = 0; epoch = 0; iter = 0; smoothLoss = -Math.log(1.0/chars.length);
    lossHistory = [];
    expertUsage = new Array(nExp).fill(0);
    batchAccumCount = 0;
    
    // Init Bars UI
    els.expertBars.innerHTML = '';
    for(let i=0; i<nExp; i++) {
        const col = document.createElement('div');
        col.className = 'expert-col';
        let label = (i === 0) ? 'Slow' : (i === nExp-1) ? 'Fast' : `E${i}`;
        col.innerHTML = `<div class="bar" id="bar-${i}" style="height: 0%"></div><div class="x-label">${label}</div>`;
        els.expertBars.appendChild(col);
    }
    
    const batchSize = parseInt(els.batchSize.value) || 1;
    els.outputArea.innerText = `// MoE-minGRU Initialized.\n// Vocab: ${chars.length}, Embedding: ${embSize}, Hidden: ${hSize}, Experts: ${nExp} (Top ${topK})\n// Batch Size: ${batchSize}\n// Architecture: Emb‚ÜíRMSNorm+Residual‚ÜíMoE‚ÜíCombine‚ÜíMLP‚ÜíOutput`;
    console.log(`Model initialized: vocab=${chars.length}, emb=${embSize}, hidden=${hSize}, experts=${nExp}, topK=${topK}, batch=${batchSize}`);
}

// Note: Now using embedding layer instead of one-hot encoding

// --- VISUALIZATION FUNCTIONS ---

function drawLossGraph() {
    if (els.lossCanvas.offsetParent === null) return;

    const ctx = els.lossCanvas.getContext('2d');
    const w = els.lossCanvas.width = els.lossCanvas.clientWidth;
    const h = els.lossCanvas.height = els.lossCanvas.clientHeight;
    
    ctx.clearRect(0, 0, w, h);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    
    ctx.beginPath();
    ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
    ctx.stroke();

    if(lossHistory.length < 2) return;

    ctx.beginPath();
    ctx.strokeStyle = '#03dac6';
    ctx.lineWidth = 2;
    
    const maxVal = Math.max(...lossHistory) * 1.1;
    const minVal = 0;
    
    for(let i=0; i<lossHistory.length; i++) {
        const x = (i / (lossHistory.length - 1)) * w;
        const y = h - ((lossHistory[i] - minVal) / (maxVal - minVal)) * h;
        if(i===0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    ctx.fillStyle = '#aaa';
    ctx.font = '10px monospace';
    ctx.fillText(`L: ${smoothLoss.toFixed(3)}`, 5, 15);
    
    // Display current learning rate and aux coefficients
    if (iter > 0) {
        const maxLR = parseFloat(els.learnRate.value);
        const warmupSteps = parseInt(els.warmupSteps.value);
        const totalSteps = parseInt(els.decaySteps.value);
        const currentLR = getLearningRate(iter, maxLR, warmupSteps, totalSteps);
        
        const maxLambda = parseFloat(els.lambdaBal.value);
        const maxGamma = parseFloat(els.gammaEnt.value);
        const auxDecayStart = Math.floor(totalSteps * 0.8);
        const currentLambda = getAuxCoefficient(iter, maxLambda, auxDecayStart, totalSteps);
        const currentGamma = getAuxCoefficient(iter, maxGamma, auxDecayStart, totalSteps);
        
        ctx.fillText(`LR: ${currentLR.toExponential(2)}`, 5, 30);
        ctx.fillText(`Œª: ${currentLambda.toFixed(4)} Œ≥: ${currentGamma.toFixed(4)}`, 5, 45);
        ctx.fillText(`Iter: ${iter} | Epoch: ${epoch}`, 5, 60);
    }
}

function updateExpertVis() {
    const maxUsage = Math.max(...expertUsage, 1);
    for(let i=0; i<expertUsage.length; i++) {
        const bar = document.getElementById(`bar-${i}`);
        if(bar) {
            const pct = (expertUsage[i] / maxUsage) * 100;
            bar.style.height = `${pct}%`;
            if(pct > 80) bar.style.background = '#bb86fc';
            else bar.style.background = '#372847';
        }
    }
}

// --- LEARNING RATE SCHEDULE ---
function getLearningRate(iter, maxLR, warmupSteps, totalSteps) {
    // Linear warmup
    if (iter < warmupSteps) {
        return maxLR * (iter / warmupSteps);
    }
    
    // Cosine decay after warmup
    const decayIter = iter - warmupSteps;
    const decaySteps = totalSteps - warmupSteps;
    const progress = Math.min(decayIter / decaySteps, 1.0);
    const cosineDecay = 0.5 * (1.0 + Math.cos(Math.PI * progress));
    const minLR = maxLR * 0.05; // Decay to 5% of max LR for final fine-tuning
    
    return minLR + (maxLR - minLR) * cosineDecay;
}

// --- AUXILIARY LOSS COEFFICIENT SCHEDULE ---
function getAuxCoefficient(iter, maxCoeff, decayStartSteps, totalSteps) {
    // Warmup aux losses gradually (too strong initially can hurt learning)
    const warmupSteps = Math.min(100, decayStartSteps / 4);
    if (iter < warmupSteps) {
        return maxCoeff * (iter / warmupSteps);
    }
    
    // Hold at max value during main training
    if (iter < decayStartSteps) {
        return maxCoeff;
    }
    
    // Linear decay to 0 in final phase (allows specialization)
    const decayProgress = (iter - decayStartSteps) / (totalSteps - decayStartSteps);
    return maxCoeff * Math.max(0, 1.0 - decayProgress);
}

// --- TRAINING LOOP (With Aux Loss & Temporal Entropy) ---

function trainStep() {
    if (!model) initModel();
    const text = els.input.value;
    const maxLR = parseFloat(els.learnRate.value);
    const warmupSteps = parseInt(els.warmupSteps.value);
    const totalSteps = parseInt(els.decaySteps.value);
    const lr = getLearningRate(iter, maxLR, warmupSteps, totalSteps);
    const hSize = parseInt(els.hiddenSize.value);
    const nExp = parseInt(els.numExperts.value);
    const topK = parseInt(els.topK.value);
    const batchSize = parseInt(els.batchSize.value) || 1;
    
    // Curriculum: gradually increase sequence length
    const seqLength = Math.min(16, 8 + Math.floor(iter / 500));
    
    // Aux loss coefficients with scheduling
    const maxLambda = parseFloat(els.lambdaBal.value);
    const maxGamma = parseFloat(els.gammaEnt.value);
    const auxDecayStart = Math.floor(totalSteps * 0.8); // Start decay at 80% of training
    const lambda = getAuxCoefficient(iter, maxLambda, auxDecayStart, totalSteps);
    const gamma = getAuxCoefficient(iter, maxGamma, auxDecayStart, totalSteps);
    
    if (iter % 200 === 0) expertUsage.fill(0);

    for (let k = 0; k < 5; k++) { 
        if (dataIdx + seqLength + 1 >= text.length) { dataIdx = 0; epoch++; }

        const G = new Graph();
        let loss = 0;
        let prev = {}; 
        let batchProbs = []; // Track for Aux Loss
        batchAccumCount++;

        for (let t = 0; t < seqLength; t++) {
            const charIx = charToIx[text[dataIdx + t]];
            const targetIx = charToIx[text[dataIdx + t + 1]];
            if (charIx === undefined || targetIx === undefined) continue;

            const result = forwardMoEGRU(G, model, hSize, nExp, topK, charIx, prev);
            prev = result;
            
            // Collect Probs
            batchProbs.push(result.denseProbs);

            // Track Usage
            result.indices.forEach(idx => expertUsage[idx]++);

            const probs = Utils.softmax(result.o.w);
            // Safe log with clamping to prevent -Inf
            const targetProb = Math.max(probs[targetIx], 1e-10);
            loss += -Math.log(targetProb);
            // Set gradient with label smoothing: d(CrossEntropy)/d(logit) = softmax - smoothed_target
            // Label smoothing prevents overconfidence and improves generalization
            const smoothing = 0.05; // Reduced from 0.1 for lower loss values
            const smoothedTarget = 1.0 - smoothing;
            const smoothedNonTarget = smoothing / (probs.length - 1);
            for(let i = 0; i < probs.length; i++) {
                if (i === targetIx) {
                    result.o.dw[i] = probs[i] - smoothedTarget;
                } else {
                    result.o.dw[i] = probs[i] - smoothedNonTarget;
                }
            }
        }

        // --- LOAD BALANCING AUX LOSS ---
        if (batchProbs.length > 0 && lambda > 0) {
            const T = batchProbs.length;
            const targetP = 1.0 / nExp;
            
            // Compute mean probability per expert
            let avgProbs = new Float64Array(nExp);
            for(let t = 0; t < T; t++) {
                for(let e = 0; e < nExp; e++) avgProbs[e] += batchProbs[t].w[e];
            }
            
            // Aux Loss Gradient Injection
            for(let e = 0; e < nExp; e++) {
                avgProbs[e] /= T;
                // d(L_balance)/d(avg) = 2 * (avg - target)
                // d(avg)/d(prob) = 1/T
                const grad = 2 * (avgProbs[e] - targetP) * lambda / T;
                
                // Backprop into each step
                for(let t = 0; t < T; t++) {
                    batchProbs[t].dw[e] += grad;
                }
            }
        }

        // --- TEMPORAL ENTROPY LOSS ---
        if (batchProbs.length > 1 && gamma > 0) {
            const T = batchProbs.length;
            
            // Compute entropy at each timestep and inject gradients
            for(let t = 0; t < T; t++) {
                for(let e = 0; e < nExp; e++) {
                    const p = batchProbs[t].w[e];
                    if(p > 1e-8) {
                        // Gradient of -H (negative entropy): d(-H)/dp = log(p) + 1
                        // We want to maximize entropy (diverse routing), so minimize -H
                        batchProbs[t].dw[e] += gamma * (Math.log(p) + 1) / T;
                    }
                }
            }
        }

        smoothLoss = smoothLoss * 0.995 + (loss/seqLength) * 0.005;
        
        // Check for NaN/Inf before backward pass
        if (!isFinite(loss) || !isFinite(smoothLoss)) {
            console.warn('Loss became non-finite, resetting model...');
            initModel();
            return;
        }
        
        G.backward();
        
        // Apply optimizer step only after accumulating batch_size gradients
        if (batchAccumCount >= batchSize) {
            // Average gradients over batch
            for (const k in model) {
                if (Object.prototype.hasOwnProperty.call(model, k)) {
                    const mat = model[k];
                    for (let i = 0; i < mat.dw.length; i++) {
                        mat.dw[i] /= batchSize;
                    }
                }
            }
            
            solver.step(model, lr, 0.01, 10.0);
            batchAccumCount = 0;
            
            // Increment iteration counter only when weights are actually updated
            iter++;
            
            // Debug: Log gradient norms every 100 iterations
            if (iter % 100 === 0) {
                let totalGradNorm = 0;
                let paramCount = 0;
                for (const k in model) {
                    if (Object.prototype.hasOwnProperty.call(model, k)) {
                        const mat = model[k];
                        for (let i = 0; i < mat.w.length; i++) {
                            totalGradNorm += mat.w[i] * mat.w[i];
                            paramCount++;
                        }
                    }
                }
                const rms = Math.sqrt(totalGradNorm / paramCount);
                console.log(`Iter ${iter}: Loss=${smoothLoss.toFixed(4)}, Param RMS=${rms.toFixed(6)}, LR=${lr.toExponential(2)}`);
            }
        }
        
        // Verify model weights are still finite
        let hasNaN = false;
        for (const k in model) {
            if (Object.prototype.hasOwnProperty.call(model, k)) {
                const mat = model[k];
                for (let i = 0; i < mat.w.length; i++) {
                    if (!isFinite(mat.w[i])) {
                        hasNaN = true;
                        break;
                    }
                }
                if (hasNaN) break;
            }
        }
        
        if (hasNaN) {
            console.warn('Model weights became non-finite, resetting...');
            initModel();
            return;
        }
        
        dataIdx += seqLength;
    }

    lossHistory.push(smoothLoss);
    if(lossHistory.length > 300) lossHistory.shift();

    drawLossGraph();
    updateExpertVis();
}

async function generateResponse(query, onChar) {
    if (!model) {
        if(onChar) onChar("\n[Error: Model not trained]");
        return;
    }
    const hSize = parseInt(els.hiddenSize.value);
    const nExp = parseInt(els.numExperts.value);
    const topK = parseInt(els.topK.value);
    
    let prev = {}; 
    const inputSeq = "Q: " + query + "\nA: ";
    
    // Seed the RNN state
    for (let i = 0; i < inputSeq.length; i++) {
        const ch = inputSeq[i];
        if (!charToIx.hasOwnProperty(ch)) continue;
        const charIx = charToIx[ch];
        const G = new Graph(false); 
        prev = forwardMoEGRU(G, model, hSize, nExp, topK, charIx, prev);
        
        prev.indices.forEach(idx => {
            const b = document.getElementById(`bar-${idx}`);
            if(b) { b.classList.add('active'); setTimeout(()=>b.classList.remove('active'), 100); }
        });
    }

    let lastCharIx = charToIx[inputSeq[inputSeq.length-1]] || charToIx[' '];
    
    // Generate
    for (let i = 0; i < 150; i++) {
        const G = new Graph(false);
        const result = forwardMoEGRU(G, model, hSize, nExp, topK, lastCharIx, prev);
        prev = result;
        
        if(i % 5 === 0) {
            await new Promise(r => setTimeout(r, 20));
            result.indices.forEach(idx => {
                const b = document.getElementById(`bar-${idx}`);
                if(b) { b.classList.add('active'); setTimeout(()=>b.classList.remove('active'), 100); }
            });
        }

        const probs = Utils.softmax(result.o.w);
        const ix = Utils.maxi(probs);
        const char = ixToChar[ix];

        if (onChar) onChar(char);
        if (char === '\n') break;

        lastCharIx = ix;
    }
}

els.btnTrain.onclick = () => {
    if (isTraining) return;
    isTraining = true;
    els.status.classList.add('active');
    els.btnTrain.disabled = true;
    els.btnStop.disabled = false;
    els.hiddenSize.disabled = true;
    els.numExperts.disabled = true;
    
    const loop = () => {
        if (!isTraining) return;
        trainStep();
        requestAnimationFrame(loop);
    };
    loop();
};

els.btnStop.onclick = () => {
    isTraining = false;
    els.status.classList.remove('active');
    els.btnTrain.disabled = false;
    els.btnStop.disabled = true;
};

els.btnAsk.onclick = async () => {
    const q = els.userQuery.value.trim();
    if (!q) return;

    els.outputArea.innerText = '';
    const fullPrompt = "Q: " + q + "\nA: ";
    els.outputArea.innerText = fullPrompt;
    
    els.btnAsk.disabled = true;
    
    await generateResponse(q, (char) => {
        els.outputArea.innerText += char;
        els.outputArea.scrollTop = els.outputArea.scrollHeight;
    });
    
    els.btnAsk.disabled = false;
};

els.userQuery.addEventListener("keyup", (e) => {
    if (e.key === "Enter") els.btnAsk.click();
});

document.querySelectorAll('.accordion-header').forEach(button => {
    const content = button.nextElementSibling;
    if (button.classList.contains('active')) {
        content.style.maxHeight = content.scrollHeight + "px";
    }

    button.addEventListener('click', () => {
        const isOpen = button.classList.contains('active');
        const content = button.nextElementSibling;
        
        button.classList.toggle('active');
        content.classList.toggle('show');

        if (!isOpen) {
            content.style.maxHeight = content.scrollHeight + "px";
            if(content.querySelector('#lossGraph')) setTimeout(drawLossGraph, 310);
        } else {
            content.style.maxHeight = "0px";
        }
    });
});

setTimeout(drawLossGraph, 100);

</script>
</body>
</html>
